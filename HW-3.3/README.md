# Домашняя работа к занятию "3.3. Операционные системы, лекция 1"

1. `chdir("/tmp")`.
2. ```
   /etc/magic.mgc
   /usr/share/misc/magic.mgc
   ```
3. Устанавливаем отладчик gdb: 
   ```
   sudo apt update     
   sudo apt install gdb
   ```
   Симулируем ситуацию — запускаем в фоне ping с перенаправлением в файл (сразу можно посмотреть PID), удаляем файл:
   ```
   ping localhost > log &
   rm log
   ```
   Убеждаемся, что файл удален, но запись в него идет (размер растет):
   ```
   sudo lsof -p 11789
   ```
   Запускаем отладчик процесса с нашим PID, с помощью системного вызова dup2 создаем копию файлового дискриптора нового файла в дескриптор 1 (stdout), при этом старый дескриптор 1 закрывается (у удаленного файла не остается дескриптора, файл удаляется окончательно); завершаем работу с отладчиком:
   ```
   sudo gdb -p 11789
   (gdb) p (int)dup2(open("/home/vagrant/log2", 1089, 0664), 1)
   (gdb) q
   ```
   Теперь можно убедится, что прежний файл окончательно удален, а запись ведется в новый файл:
   ```
   sudo lsof -p 11789
   cat log2
   ```

4. Ресурсов зомби процессы не занимают, но занимают место в списке процессов и могут помешать запустить новый процесс при приближении к лимиту на количество запущенных процессов для пользователя.

5. ```
   vagrant@vagrant:~$ sudo opensnoop-bpfcc
   PID    COMM               FD ERR PATH
   857    vminfo              4   0 /var/run/utmp
   659    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
   659    dbus-daemon        20   0 /usr/share/dbus-1/system-services
   659    dbus-daemon        -1   2 /lib/dbus-1/system-services
   659    dbus-daemon        20   0 /var/lib/snapd/dbus-1/system-services/
   ```
   
6. `uname -a` Использует системный вызов `uname`.  
   `Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.`

7. `;` — используется для запуска нескольких команд, причем команда, следующая за `;` выполнится независимо от корректности выполнения предыдущей команды. `&&` используется для условного выполнения нескольких команд — команда после `&&` выполняется только при успешном выполнении предыдущей команды.
   В приведенном примере, в первом случае `Hi` будет выведено при любом результате выполнения первой команды, в то время как во втором случае `Hi` будет выведено только при наличии директории `/tmp/some_dir`
   С включенной опцией `-e` нет смысла использовать в bash-скрипте `&&`, т.к. сценарий завершится с ошибкой при ошибке в любой команде.

8. `set -euxo pipefail` состоит из следующих опций:  
   `-e` — немедленное завершение сценария при ошибке выполнения какой-либо команды (не нулевой код выхода).  
   `-u` — bash обрабатывает неустановленные переменные как ошибку и немедленно завершает работу сценария.  
   `-x` — bash будет печатать каждую команду перед ее выполнением, аргументы расширяются до того, как команда будет напечатана, вывод будет содержать фактические значения аргументов, которые присутствовали во время выполнения.  
   `-o pipefail` — устанавливает код выхода конвейера равным коду самой правой команды для завершения с ненулевым статусом или равным нулю, если все команды конвейера завершаются успешно. Такое поведение позволяет опции `-e` влиять на все команда конвейера, а не только на последнюю.  
   Этот режим желательно применять в сценариях для более четкого контроля корректности выполнения сценария — любая ошибка приводит к аварийному завершению сценария, причем по выводу можно будет легко определить, в каком месте происходит ошибка.

9. Самый распространенный статус — `S` — режим прерываемого сна (ожидание события для прерывания сна).  
   Дополнительные символы статуса процесса:  
   `<` — высокоприоритетный (плохо для других пользователей);  
   `N` — низкоприоритетный (хорошо для других пользователей);  
   `L` — имеет страницы, заблокированные в памяти (для ввода-вывода в реальном времени и пользовательского ввода-вывода);  
   `s` — является лидером сеанса;  
   `l` — многопоточный (с использованием CLONE_THREAD, как это делает NPTL pthreads);  
   `+` — находится в группе процессов переднего плана (fg).  
