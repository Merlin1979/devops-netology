# Домашняя работа к занятию "3.2. Работа в терминале, лекция 2"

1. `type -f cd`. `cd` — встроенная команда. `cd` изменяет атрибут `CWD` (Current Working directory) процесса текущей оболочки. Если бы она была внешней, то запускалась бы дочерним процессом, который хоть и наследует `CWD` от родительского процесса, изменить `CWD` родителя не сможет.
2. `grep -c <some_string> <some_file>`
3. `pstree -p`. Родительский процесс с PID 1 — `systemd`.
4. `ls /root 2> /dev/pts/1`
5. Получится, например, `cat < sample.txt > sample_out.txt`.
6. Получится, например, `echo test > /dev/tty3`. Чтобы увидеть вывод нужно переключиься в соответствующий эмулятор терминала (в данном случае, Ctrl-Alt-F3). Причем вывод будет осуществлен непосредственно в текщую позицию экрана.
7. Команда `bash 5>&1` создает файловый дескриптор `5`, и перенаправляет его на файловый дескриптор `1 (stdout)`. Если после этого выполнить команду `echo netology > /proc/$$/fd/5`, то на экран будет выведена строка `netology`, т.к. эта команда перенаправляет вывод на 5-й файловый дескриптор текущего процесса оболочки, который в свою очередь ссылается на 1-й (stdout).
8. Получится, например, `ls /root 3>&1 1>&2 2>&3 | grep t`.
9. `cat /proc/$$/environ` выведет список переменных окружения текущего процесса на момент запуска. Аналогичный вывод можно получить по команде 'ps e -ww -p $$'.
10. `/proc/[pid]/cmdline`
Этот файл, доступный только для чтения, содержит полную командную строку для процесса, если только это не зомби-процесс. В этом случае в файле ничего нет: то есть чтение этого файла вернет 0 символов. Аргументы командной строки отображаются в этом файле в виде набора строк, разделенных нулевыми байтами ('\0'), с дополнительным нулевым байтом после последней строки.    
`/proc/[pid]/exe`
В Linux 2.2 и более поздних версиях этот файл представляет собой символическую ссылку, содержащую фактический путь к выполняемой команде. Эта символическая ссылка может быть разыменована в обычном режиме; попытка открыть ее приведет к открытию исполняемого файла. Вы даже можете ввести `/proc/[pid]/exe`, чтобы запустить другую копию того же исполняемого файла, который запускается процессом [pid]. Если имя пути было разорвано, символическая ссылка будет содержать строку '(deleted)', добавленную к исходному имени пути. В многопоточном процессе содержимое этой символической ссылки недоступно, если основной поток уже завершен (обычно путем вызова pthread_exit(3)).
11. `cat /proc/cpuinfo | grep sse`. SSE 4.2 (sse4_2).
12. По умолчанию, если `ssh` запускается в режиме выполнения команды, виртуальный терминал не выделяется. Чтобы исправить такое поведение можно импользовать ключ `-t`:
`ssh -t localhost 'tty'`.
13. Для начала нужно установить reptyr: `$ sudo apt install reptyr`.
    Редактируем файл настроек `nano /etc/sysctl.d/10-ptrace.conf`, нужно изменить значение параметра `kernel.yama.ptrace_scope` на `0` и перезагрузить правило `sudo sysctl -p /etc/sysctl.d/10-ptrace.conf`. Без этого попытка перехвата через reptyr приводит к ошибке о недостке разрешений.
    В окне первой ssh-сессии запускаем процесс, например `top`.
    Останавливаем процесс через сочетание клавиш `Ctrl-Z` и переводим в фоновое выполнение командой `bg`.
    Во втором окне запускаем `screen`, выясняем PID нужного процесса, перехватываем процесс по его PID (в нашем случае 5391):
    ```
    screen
    ps -a
    reptyr 5391
    ```
    Первую ssh-сессию после этого можно завершить.
14. Команда `tee` читает `stdin` и пишет в `stdout` и файлы. Во второй команде вывод `echo`, запущенной с правами текущего пользователя перенаправляется оболочкой, также запущенной с правами текущего пользователя, на вход команды `tee`, запущенной с повышенными привилегиями, поэтому у нее есть права на запись в указанный файл.
